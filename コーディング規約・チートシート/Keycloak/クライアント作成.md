---
作成日: 2025-05-27
tags:
  - Keycloak
  - 認証
  - 認可
---
# Keycloak クライアント設定ガイド

このドキュメントでは、異なるアプリケーションタイプに対応したKeycloakクライアントの設定方法を説明します。

## 前提条件

- Keycloak管理コンソールへのアクセス権限
- 適切なRealmが作成済み（例：`company_realm`）
- 管理者権限でのKeycloakへのログイン

## 1. REST API用クライアント設定

### 用途

- バックエンドAPI間の認証
- マイクロサービス間通信
- サーバー間認証

### 基本設定

- **Client type**: `OpenID Connect`
- **Client ID**: `api-service-client`
- **Name**: `API Service Client`
- **Description**: `API用クライアント`
- **Always display in UI**: `On`

### Capability config

```
✅ Client authentication: On (機密クライアント)
❌ Authorization: Off
```

### Authentication flow

```
❌ Standard flow: Off
❌ Direct access grants: Off
❌ Implicit flow: Off
✅ Service accounts roles: On (重要)
✅ Standard Token Exchange: On
❌ OAuth 2.0 Device Authorization Grant: Off
❌ OIDC CIBA Grant: Off
```

### Access settings

- **Root URL**: 空白
- **Home URL**: 空白
- **Valid redirect URIs**: 空白
- **Valid post logout redirect URIs**: 空白
- **Web origins**: 空白

### 認証フロー

**Client Credentials Grant** を使用

### トークン取得例

```bash
curl -X POST http://localhost:8180/realms/company-realm/protocol/openid-connect/token `
  -H "Content-Type: application/x-www-form-urlencoded" `
  -d "grant_type=client_credentials" `
  -d "client_id=api-service-client" `
  -d "client_secret=<クライアントシークレット>"
```

### API呼び出し例

```bash
curl -X GET http://your-api-endpoint/resource \
  -H "Authorization: Bearer <アクセストークン>"
```

---

## 2. WPFアプリ用クライアント設定

### 用途

- デスクトップアプリケーション
- Windows WPFアプリケーション
- ネイティブアプリケーション

### 基本設定

- **Client type**: `OpenID Connect`
- **Client ID**: `wpf-app-client`
- **Name**: `WPF Desktop Application Client`
- **Description**: `WPF用クライアント`
- **Always display in UI**: `On`

### Capability config

```
❌ Client authentication: Off (パブリッククライアント)
❌ Authorization: Off
```

### Authentication flow

```
✅ Standard flow: On (Authorization Code Flow)
❌ Direct access grants: Off
❌ Implicit flow: Off
❌ Service accounts roles: Off
❌ Standard Token Exchange: Off
❌ OAuth 2.0 Device Authorization Grant: Off
❌ OIDC CIBA Grant: Off
```

### Access settings

- **Root URL**: 空白
- **Home URL**: 空白
- **Valid redirect URIs**:
    - `http://localhost:*`
    - `urn:ietf:wg:oauth:2.0:oob`
- **Valid post logout redirect URIs**: `http://localhost:*`
- **Web origins**: `*`

### 認証フロー

**Authorization Code Flow with PKCE** を使用

### セキュリティ考慮点

- Client Secretは使用しない（パブリッククライアント）
- PKCEでセキュリティを確保
- システムブラウザーまたは埋め込みブラウザーを使用

---

## 3. Webアプリ用クライアント設定

### 用途

- Blazor Server/WebAssemblyアプリケーション
- ASP.NET Core Webアプリケーション
- サーバーサイドWebアプリケーション

### 基本設定

- **Client type**: `OpenID Connect`
- **Client ID**: `web-app-client`
- **Name**: `Web Application Client`
- **Description**: `Webアプリケーション用クライアント`
- **Always display in UI**: `On`

### Capability config

```
✅ Client authentication: On (機密クライアント)
❌ Authorization: Off
```

### Authentication flow

```
✅ Standard flow: On (Authorization Code Flow)
❌ Direct access grants: Off
❌ Implicit flow: Off
❌ Service accounts roles: Off
✅ Standard Token Exchange: On
❌ OAuth 2.0 Device Authorization Grant: Off
❌ OIDC CIBA Grant: Off
```

### Access settings

- **Root URL**: `http://localhost:5000`
- **Home URL**: `http://localhost:5000`
- **Valid redirect URIs**:
    - `http://localhost:5000/signin-oidc`
    - `http://localhost:5000/authentication/login-callback`
- **Valid post logout redirect URIs**:
    - `http://localhost:5000/signout-callback-oidc`
    - `http://localhost:5000/authentication/logout-callback`
- **Web origins**: `http://localhost:5000`

### 認証フロー

**Authorization Code Flow** を使用

### セキュリティ考慮点

- Client Secretをサーバーサイドで安全に管理
- 開発環境ではHTTPも使用可能（本番環境ではHTTPS推奨）
- 標準的なWeb認証フロー

---

## 設定比較表

| 項目                         | REST API           | WPF Desktop               | Web                |
| -------------------------- | ------------------ | ------------------------- | ------------------ |
| **Client Type**            | 機密                 | パブリック                     | 機密                 |
| **Client Authentication**  | On                 | Off                       | On                 |
| **Standard Flow**          | Off                | On                        | On                 |
| **Service Accounts Roles** | On                 | Off                       | Off                |
| **認証フロー**                  | Client Credentials | Authorization Code + PKCE | Authorization Code |
| **Client Secret**          | 必要                 | 不要                        | 必要                 |
| **リダイレクトURI**              | 不要                 | ローカルホスト                   | 固定URL              |
| **主な用途**                   | API間認証             | ユーザー認証                    | ユーザー認証             |

---

## Role-Based Access Control (RBAC) 設定

### Realm Roleの作成

1. 左メニュー「Realm roles」→「Create role」
2. 各アプリケーション用のRoleを作成：
    - `admin`: 管理者ユーザー
    - `general`: 一般ユーザー
    - `guest`: ゲストユーザー

### ClientへのRole割り当て

**API用（Service Account）**:

1. 「Clients」→「api-service-client」→「Service accounts roles」
2. 「Assign role」で`api-user`を割り当て

**WPF/Blazor用（User Role）**:

1. 「Users」→対象ユーザー→「Role mapping」
2. 適切なRoleを割り当て

---

## JWT検証に必要な情報

### 共通設定値

- **Issuer**: `http://localhost:8180/realms/company_realm`
- **JWKS URI**: `http://localhost:8180/realms/company_realm/protocol/openid-connect/certs`
- **Token Endpoint**: `http://localhost:8180/realms/company_realm/protocol/openid-connect/token`
- **Authorization Endpoint**: `http://localhost:8180/realms/company_realm/protocol/openid-connect/auth`

### API側での検証項目

- JWT署名の検証
- Issuerの確認
- 有効期限の確認
- Audienceの確認
- Role/Scopeの確認

---

## セキュリティベストプラクティス

### 共通

- 本番環境では必ずHTTPS使用（開発環境ではHTTPも可）
- 適切なToken有効期限設定
- 最小権限の原則に従ったRole設計

### API用

- Client Secretの安全な管理
- ネットワークレベルでのアクセス制限
- ログ監査の実装

### デスクトップ用

- PKCEの実装
- Token保存時の暗号化
- システムブラウザーの使用推奨

### Web用

- CSRF保護の実装
- Secure Cookieの使用（HTTPS環境の場合）
- Content Security Policy設定
- 開発環境ではHTTP使用可（本番環境ではHTTPS必須）

---

## トラブルシューティング

### よくあるエラー

**Invalid client credentials**

- Client IDとSecretの確認
- Client認証設定の確認

**Invalid redirect URI**

- リダイレクトURIの正確な設定
- HTTPとHTTPSプロトコルの違いに注意
- ポート番号の確認

**Token validation failed**

- JWKS URIの確認
- システム時刻の同期確認

### デバッグ方法

- Keycloakログの確認
- JWT.ioでトークン内容確認
- ブラウザー開発者ツールでネットワーク確認
